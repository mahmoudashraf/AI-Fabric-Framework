package com.foundation.ai.integration;

import com.ai.infrastructure.dto.AISearchRequest;
import com.ai.infrastructure.dto.AISearchResponse;
import com.ai.infrastructure.dto.AdvancedRAGRequest;
import com.ai.infrastructure.dto.AdvancedRAGResponse;
import com.ai.infrastructure.rag.AdvancedRAGService;
import com.ai.infrastructure.audit.AIAuditService;
import com.ai.infrastructure.security.AISecurityService;
import com.ai.infrastructure.exception.AIServiceException;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

/**
 * Integration tests for Advanced RAG services
 * Tests the complete flow from document indexing to search and retrieval
 */
@SpringBootTest
@ActiveProfiles("test")
@Transactional
class AIAdvancedRAGIntegrationTest {

    @Autowired
    private AdvancedRAGService advancedRAGService;

    @Autowired
    private AIAuditService aiAuditService;

    @Autowired
    private AISecurityService aiSecurityService;

    private AISearchRequest searchRequest;
    private AdvancedRAGRequest advancedRAGRequest;

    @BeforeEach
    void setUp() {
        searchRequest = AISearchRequest.builder()
                .query("machine learning algorithms for natural language processing")
                .limit(10)
                .build();

        advancedRAGRequest = AdvancedRAGRequest.builder()
                .query("AI security best practices")
                .maxResults(10)
                .build();
    }

    @Test
    @DisplayName("Complete RAG search and retrieval flow")
    void testCompleteRAGFlow() throws Exception {
        // Test that the service is properly instantiated
        assertNotNull(advancedRAGService);
        
        // Test that we can create request objects
        assertNotNull(searchRequest);
        assertNotNull(advancedRAGRequest);
        
        // Test that the service method can be called
        AdvancedRAGResponse response = advancedRAGService.performAdvancedRAG(advancedRAGRequest);
        
        assertNotNull(response);
        assertNotNull(response.getRequestId());
    }

    @Test
    @DisplayName("Real-time search and retrieval")
    void testRealTimeSearchAndRetrieval() throws Exception {
        // Simulate real-time search
        CompletableFuture<SearchResponse> future = CompletableFuture.supplyAsync(() -> {
            try {
                return advancedRAGService.search(searchRequest);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });

        SearchResponse response = future.get(5, TimeUnit.SECONDS);
        
        assertNotNull(response);
        assertTrue(response.getProcessingTimeMs() < 5000); // Should be fast for real-time
        
        // Verify metrics are updated
        RAGMetricsResponse metrics = advancedRAGService.getRAGMetrics();
        assertNotNull(metrics);
        assertTrue(metrics.getTotalSearches() >= 0);
        assertTrue(metrics.getAverageResponseTime() > 0);
    }

    @Test
    @DisplayName("Search with different strategies and configurations")
    void testSearchWithDifferentStrategies() throws Exception {
        // Test semantic search
        SearchRequest semanticRequest = searchRequest.toBuilder()
                .rerankingStrategy("semantic")
                .enableHybridSearch(false)
                .build();
        
        SearchResponse semanticResponse = advancedRAGService.search(semanticRequest);
        assertNotNull(semanticResponse);
        assertEquals("semantic", semanticResponse.getRerankingStrategy());
        
        // Test hybrid search
        SearchRequest hybridRequest = searchRequest.toBuilder()
                .rerankingStrategy("hybrid")
                .enableHybridSearch(true)
                .build();
        
        SearchResponse hybridResponse = advancedRAGService.search(hybridRequest);
        assertNotNull(hybridResponse);
        assertEquals("hybrid", hybridResponse.getRerankingStrategy());
        
        // Test diversity search
        SearchRequest diversityRequest = searchRequest.toBuilder()
                .rerankingStrategy("diversity")
                .enableHybridSearch(false)
                .build();
        
        SearchResponse diversityResponse = advancedRAGService.search(diversityRequest);
        assertNotNull(diversityResponse);
        assertEquals("diversity", diversityResponse.getRerankingStrategy());
    }

    @Test
    @DisplayName("Query expansion with different levels")
    void testQueryExpansionWithDifferentLevels() throws Exception {
        // Test level 1 expansion
        QueryExpansionRequest level1Request = queryExpansionRequest.toBuilder()
                .expansionLevel(1)
                .build();
        
        QueryExpansionResponse level1Response = advancedRAGService.expandQuery(level1Request);
        assertNotNull(level1Response);
        assertTrue(level1Response.getExpandedQueries().size() >= 1);
        
        // Test level 2 expansion
        QueryExpansionRequest level2Request = queryExpansionRequest.toBuilder()
                .expansionLevel(2)
                .build();
        
        QueryExpansionResponse level2Response = advancedRAGService.expandQuery(level2Request);
        assertNotNull(level2Response);
        assertTrue(level2Response.getExpandedQueries().size() >= level1Response.getExpandedQueries().size());
        
        // Test level 3 expansion
        QueryExpansionRequest level3Request = queryExpansionRequest.toBuilder()
                .expansionLevel(3)
                .build();
        
        QueryExpansionResponse level3Response = advancedRAGService.expandQuery(level3Request);
        assertNotNull(level3Response);
        assertTrue(level3Response.getExpandedQueries().size() >= level2Response.getExpandedQueries().size());
    }

    @Test
    @DisplayName("Document indexing and management")
    void testDocumentIndexingAndManagement() throws Exception {
        // Index document
        DocumentIndexResponse indexResponse = advancedRAGService.indexDocument(documentIndexRequest);
        assertNotNull(indexResponse);
        assertNotNull(indexResponse.getDocumentId());
        
        // Update document
        DocumentIndexRequest updateRequest = documentIndexRequest.toBuilder()
                .title("Updated AI Security Best Practices")
                .content("This updated document covers advanced best practices for AI security including model protection, data privacy, threat detection, and compliance.")
                .metadata(Map.of("author", "AI Team", "version", "2.0", "language", "en", "updated", "true"))
                .build();
        
        DocumentIndexResponse updatedResponse = advancedRAGService.updateDocument(
                indexResponse.getDocumentId(), updateRequest);
        
        assertNotNull(updatedResponse);
        assertEquals("Updated AI Security Best Practices", updatedResponse.getTitle());
        
        // Delete document
        advancedRAGService.deleteDocument(indexResponse.getDocumentId());
        
        // Verify document is deleted
        assertThrows(AIProcessingException.class, () -> {
            advancedRAGService.getDocument(indexResponse.getDocumentId());
        });
    }

    @Test
    @DisplayName("Error handling and recovery")
    void testErrorHandlingAndRecovery() {
        // Test with invalid search request
        SearchRequest invalidRequest = SearchRequest.builder()
                .query("")
                .maxResults(-1)
                .maxDocuments(-1)
                .build();
        
        assertThrows(AIProcessingException.class, () -> {
            advancedRAGService.search(invalidRequest);
        });
        
        // Test with null request
        assertThrows(AIProcessingException.class, () -> {
            advancedRAGService.search(null);
        });
        
        // Test with invalid document index request
        DocumentIndexRequest invalidIndexRequest = DocumentIndexRequest.builder()
                .title("")
                .content("")
                .build();
        
        assertThrows(AIProcessingException.class, () -> {
            advancedRAGService.indexDocument(invalidIndexRequest);
        });
    }

    @Test
    @DisplayName("Performance and scalability")
    void testPerformanceAndScalability() throws Exception {
        long startTime = System.currentTimeMillis();
        
        // Simulate multiple concurrent searches
        List<CompletableFuture<SearchResponse>> futures = List.of(
                CompletableFuture.supplyAsync(() -> {
                    try {
                        return advancedRAGService.search(searchRequest);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }),
                CompletableFuture.supplyAsync(() -> {
                    try {
                        return advancedRAGService.search(searchRequest);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }),
                CompletableFuture.supplyAsync(() -> {
                    try {
                        return advancedRAGService.search(searchRequest);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                })
        );
        
        // Wait for all to complete
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get(10, TimeUnit.SECONDS);
        
        long endTime = System.currentTimeMillis();
        long totalTime = endTime - startTime;
        
        // Should complete within reasonable time
        assertTrue(totalTime < 10000); // 10 seconds
        
        // All responses should be valid
        for (CompletableFuture<SearchResponse> future : futures) {
            SearchResponse response = future.get();
            assertNotNull(response);
            assertNotNull(response.getDocuments());
        }
    }

    @Test
    @DisplayName("Integration with audit and security systems")
    void testIntegrationWithAuditAndSecurity() throws Exception {
        // Perform RAG operation
        SearchResponse searchResponse = advancedRAGService.search(searchRequest);
        
        // Verify audit trail
        var auditLogs = aiAuditService.getAuditLogs(0, 10, "timestamp", "desc");
        assertNotNull(auditLogs);
        
        // Check if RAG operation was logged
        boolean ragOperationLogged = auditLogs.getLogs().stream()
                .anyMatch(log -> log.getOperationType().equals("RAG_SEARCH"));
        assertTrue(ragOperationLogged);
        
        // Verify security integration
        var securityMetrics = aiSecurityService.getSecurityMetrics();
        assertNotNull(securityMetrics);
        
        // Verify metrics are updated
        RAGMetricsResponse metrics = advancedRAGService.getRAGMetrics();
        assertNotNull(metrics);
        assertTrue(metrics.getTotalSearches() >= 0);
    }

    @Test
    @DisplayName("Context optimization and relevance scoring")
    void testContextOptimizationAndRelevanceScoring() throws Exception {
        // Test with different context optimization levels
        SearchRequest lowContextRequest = searchRequest.toBuilder()
                .contextOptimizationLevel("low")
                .build();
        
        SearchResponse lowContextResponse = advancedRAGService.search(lowContextRequest);
        assertNotNull(lowContextResponse);
        assertEquals("low", lowContextResponse.getContextOptimizationLevel());
        
        // Test with high context optimization
        SearchRequest highContextRequest = searchRequest.toBuilder()
                .contextOptimizationLevel("high")
                .build();
        
        SearchResponse highContextResponse = advancedRAGService.search(highContextRequest);
        assertNotNull(highContextResponse);
        assertEquals("high", highContextResponse.getContextOptimizationLevel());
        
        // High context optimization should provide better relevance scores
        assertTrue(highContextResponse.getConfidenceScore() >= lowContextResponse.getConfidenceScore());
    }
}